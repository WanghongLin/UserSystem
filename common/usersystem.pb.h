// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: usersystem.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_usersystem_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_usersystem_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3008000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3008000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_usersystem_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_usersystem_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace usersystem {
class CheckLoginRequest;
class CheckLoginRequestDefaultTypeInternal;
extern CheckLoginRequestDefaultTypeInternal _CheckLoginRequest_default_instance_;
class CheckLoginResponse;
class CheckLoginResponseDefaultTypeInternal;
extern CheckLoginResponseDefaultTypeInternal _CheckLoginResponse_default_instance_;
class CommonResponse;
class CommonResponseDefaultTypeInternal;
extern CommonResponseDefaultTypeInternal _CommonResponse_default_instance_;
class Geo;
class GeoDefaultTypeInternal;
extern GeoDefaultTypeInternal _Geo_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LogoutRequest;
class LogoutRequestDefaultTypeInternal;
extern LogoutRequestDefaultTypeInternal _LogoutRequest_default_instance_;
class RegisterRequest;
class RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class UserLoginHistoryModel;
class UserLoginHistoryModelDefaultTypeInternal;
extern UserLoginHistoryModelDefaultTypeInternal _UserLoginHistoryModel_default_instance_;
class UserModel;
class UserModelDefaultTypeInternal;
extern UserModelDefaultTypeInternal _UserModel_default_instance_;
}  // namespace usersystem
PROTOBUF_NAMESPACE_OPEN
template<> ::usersystem::CheckLoginRequest* Arena::CreateMaybeMessage<::usersystem::CheckLoginRequest>(Arena*);
template<> ::usersystem::CheckLoginResponse* Arena::CreateMaybeMessage<::usersystem::CheckLoginResponse>(Arena*);
template<> ::usersystem::CommonResponse* Arena::CreateMaybeMessage<::usersystem::CommonResponse>(Arena*);
template<> ::usersystem::Geo* Arena::CreateMaybeMessage<::usersystem::Geo>(Arena*);
template<> ::usersystem::LoginRequest* Arena::CreateMaybeMessage<::usersystem::LoginRequest>(Arena*);
template<> ::usersystem::LoginResponse* Arena::CreateMaybeMessage<::usersystem::LoginResponse>(Arena*);
template<> ::usersystem::LogoutRequest* Arena::CreateMaybeMessage<::usersystem::LogoutRequest>(Arena*);
template<> ::usersystem::RegisterRequest* Arena::CreateMaybeMessage<::usersystem::RegisterRequest>(Arena*);
template<> ::usersystem::RegisterResponse* Arena::CreateMaybeMessage<::usersystem::RegisterResponse>(Arena*);
template<> ::usersystem::UserLoginHistoryModel* Arena::CreateMaybeMessage<::usersystem::UserLoginHistoryModel>(Arena*);
template<> ::usersystem::UserModel* Arena::CreateMaybeMessage<::usersystem::UserModel>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace usersystem {

enum UserModel_UserGender : int {
  UserModel_UserGender_MALE = 0,
  UserModel_UserGender_FEMALE = 1,
  UserModel_UserGender_NEUTER = 2
};
bool UserModel_UserGender_IsValid(int value);
constexpr UserModel_UserGender UserModel_UserGender_UserGender_MIN = UserModel_UserGender_MALE;
constexpr UserModel_UserGender UserModel_UserGender_UserGender_MAX = UserModel_UserGender_NEUTER;
constexpr int UserModel_UserGender_UserGender_ARRAYSIZE = UserModel_UserGender_UserGender_MAX + 1;

enum ResponseCode : int {
  OK = 0,
  ERROR_REGISTER_USERNAME_HAS_BEEN_TAKEN = 1,
  ERROR_REGISTER_EMPTY_USERNAME_PASSWORD = 2,
  ERROR_LOGIN_WRONG_USERNAME = 3,
  ERROR_LOGIN_WRONG_PASSWORD = 4,
  ERROR_LOGIN_STATUS_INVALID = 5,
  ERROR_ANDROID_JNI_CALL = 6,
  ERROR_GRPC_ERROR = 7,
  ERROR_INVALID_USERNAME = 8,
  ERROR_UNKNOWN = 9
};
bool ResponseCode_IsValid(int value);
constexpr ResponseCode ResponseCode_MIN = OK;
constexpr ResponseCode ResponseCode_MAX = ERROR_UNKNOWN;
constexpr int ResponseCode_ARRAYSIZE = ResponseCode_MAX + 1;

enum Platform : int {
  Type_Desktop = 0,
  Type_Android = 1,
  Type_iOS = 2
};
bool Platform_IsValid(int value);
constexpr Platform Platform_MIN = Type_Desktop;
constexpr Platform Platform_MAX = Type_iOS;
constexpr int Platform_ARRAYSIZE = Platform_MAX + 1;

// ===================================================================

class Geo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.Geo) */ {
 public:
  Geo();
  virtual ~Geo();

  Geo(const Geo& from);
  Geo(Geo&& from) noexcept
    : Geo() {
    *this = ::std::move(from);
  }

  inline Geo& operator=(const Geo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geo& operator=(Geo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Geo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geo* internal_default_instance() {
    return reinterpret_cast<const Geo*>(
               &_Geo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Geo* other);
  friend void swap(Geo& a, Geo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Geo* New() const final {
    return CreateMaybeMessage<Geo>(nullptr);
  }

  Geo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Geo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Geo& from);
  void MergeFrom(const Geo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Geo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.Geo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lat = 1;
  bool has_lat() const;
  void clear_lat();
  static const int kLatFieldNumber = 1;
  double lat() const;
  void set_lat(double value);

  // required double lng = 2;
  bool has_lng() const;
  void clear_lng();
  static const int kLngFieldNumber = 2;
  double lng() const;
  void set_lng(double value);

  // @@protoc_insertion_point(class_scope:usersystem.Geo)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double lat_;
  double lng_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class UserModel :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.UserModel) */ {
 public:
  UserModel();
  virtual ~UserModel();

  UserModel(const UserModel& from);
  UserModel(UserModel&& from) noexcept
    : UserModel() {
    *this = ::std::move(from);
  }

  inline UserModel& operator=(const UserModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserModel& operator=(UserModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const UserModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserModel* internal_default_instance() {
    return reinterpret_cast<const UserModel*>(
               &_UserModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UserModel* other);
  friend void swap(UserModel& a, UserModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserModel* New() const final {
    return CreateMaybeMessage<UserModel>(nullptr);
  }

  UserModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserModel>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const UserModel& from);
  void MergeFrom(const UserModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.UserModel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef UserModel_UserGender UserGender;
  static constexpr UserGender MALE =
    UserModel_UserGender_MALE;
  static constexpr UserGender FEMALE =
    UserModel_UserGender_FEMALE;
  static constexpr UserGender NEUTER =
    UserModel_UserGender_NEUTER;
  static inline bool UserGender_IsValid(int value) {
    return UserModel_UserGender_IsValid(value);
  }
  static constexpr UserGender UserGender_MIN =
    UserModel_UserGender_UserGender_MIN;
  static constexpr UserGender UserGender_MAX =
    UserModel_UserGender_UserGender_MAX;
  static constexpr int UserGender_ARRAYSIZE =
    UserModel_UserGender_UserGender_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // required string username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // optional string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // optional string phone_number = 6;
  bool has_phone_number() const;
  void clear_phone_number();
  static const int kPhoneNumberFieldNumber = 6;
  const std::string& phone_number() const;
  void set_phone_number(const std::string& value);
  void set_phone_number(std::string&& value);
  void set_phone_number(const char* value);
  void set_phone_number(const char* value, size_t size);
  std::string* mutable_phone_number();
  std::string* release_phone_number();
  void set_allocated_phone_number(std::string* phone_number);

  // optional .usersystem.Geo geo = 7;
  bool has_geo() const;
  void clear_geo();
  static const int kGeoFieldNumber = 7;
  const ::usersystem::Geo& geo() const;
  ::usersystem::Geo* release_geo();
  ::usersystem::Geo* mutable_geo();
  void set_allocated_geo(::usersystem::Geo* geo);

  // optional int32 age = 4;
  bool has_age() const;
  void clear_age();
  static const int kAgeFieldNumber = 4;
  ::PROTOBUF_NAMESPACE_ID::int32 age() const;
  void set_age(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .usersystem.UserModel.UserGender gender = 5;
  bool has_gender() const;
  void clear_gender();
  static const int kGenderFieldNumber = 5;
  ::usersystem::UserModel_UserGender gender() const;
  void set_gender(::usersystem::UserModel_UserGender value);

  // optional uint64 create_at_millis = 8;
  bool has_create_at_millis() const;
  void clear_create_at_millis();
  static const int kCreateAtMillisFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint64 create_at_millis() const;
  void set_create_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 update_at_millis = 9;
  bool has_update_at_millis() const;
  void clear_update_at_millis();
  static const int kUpdateAtMillisFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint64 update_at_millis() const;
  void set_update_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:usersystem.UserModel)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr phone_number_;
  ::usersystem::Geo* geo_;
  ::PROTOBUF_NAMESPACE_ID::int32 age_;
  int gender_;
  ::PROTOBUF_NAMESPACE_ID::uint64 create_at_millis_;
  ::PROTOBUF_NAMESPACE_ID::uint64 update_at_millis_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class UserLoginHistoryModel :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.UserLoginHistoryModel) */ {
 public:
  UserLoginHistoryModel();
  virtual ~UserLoginHistoryModel();

  UserLoginHistoryModel(const UserLoginHistoryModel& from);
  UserLoginHistoryModel(UserLoginHistoryModel&& from) noexcept
    : UserLoginHistoryModel() {
    *this = ::std::move(from);
  }

  inline UserLoginHistoryModel& operator=(const UserLoginHistoryModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserLoginHistoryModel& operator=(UserLoginHistoryModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const UserLoginHistoryModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserLoginHistoryModel* internal_default_instance() {
    return reinterpret_cast<const UserLoginHistoryModel*>(
               &_UserLoginHistoryModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(UserLoginHistoryModel* other);
  friend void swap(UserLoginHistoryModel& a, UserLoginHistoryModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserLoginHistoryModel* New() const final {
    return CreateMaybeMessage<UserLoginHistoryModel>(nullptr);
  }

  UserLoginHistoryModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserLoginHistoryModel>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const UserLoginHistoryModel& from);
  void MergeFrom(const UserLoginHistoryModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserLoginHistoryModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.UserLoginHistoryModel";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);

  // required string username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // required string token = 3;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // required string device_id = 4;
  bool has_device_id() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 4;
  const std::string& device_id() const;
  void set_device_id(const std::string& value);
  void set_device_id(std::string&& value);
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  std::string* mutable_device_id();
  std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);

  // required .usersystem.Platform from_platform = 5;
  bool has_from_platform() const;
  void clear_from_platform();
  static const int kFromPlatformFieldNumber = 5;
  ::usersystem::Platform from_platform() const;
  void set_from_platform(::usersystem::Platform value);

  // required bool is_valid = 6;
  bool has_is_valid() const;
  void clear_is_valid();
  static const int kIsValidFieldNumber = 6;
  bool is_valid() const;
  void set_is_valid(bool value);

  // optional uint64 create_at_millis = 7;
  bool has_create_at_millis() const;
  void clear_create_at_millis();
  static const int kCreateAtMillisFieldNumber = 7;
  ::PROTOBUF_NAMESPACE_ID::uint64 create_at_millis() const;
  void set_create_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 update_at_millis = 8;
  bool has_update_at_millis() const;
  void clear_update_at_millis();
  static const int kUpdateAtMillisFieldNumber = 8;
  ::PROTOBUF_NAMESPACE_ID::uint64 update_at_millis() const;
  void set_update_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 expire_at_millis = 9;
  bool has_expire_at_millis() const;
  void clear_expire_at_millis();
  static const int kExpireAtMillisFieldNumber = 9;
  ::PROTOBUF_NAMESPACE_ID::uint64 expire_at_millis() const;
  void set_expire_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:usersystem.UserLoginHistoryModel)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  int from_platform_;
  bool is_valid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 create_at_millis_;
  ::PROTOBUF_NAMESPACE_ID::uint64 update_at_millis_;
  ::PROTOBUF_NAMESPACE_ID::uint64 expire_at_millis_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class CommonResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.CommonResponse) */ {
 public:
  CommonResponse();
  virtual ~CommonResponse();

  CommonResponse(const CommonResponse& from);
  CommonResponse(CommonResponse&& from) noexcept
    : CommonResponse() {
    *this = ::std::move(from);
  }

  inline CommonResponse& operator=(const CommonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonResponse& operator=(CommonResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CommonResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommonResponse* internal_default_instance() {
    return reinterpret_cast<const CommonResponse*>(
               &_CommonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CommonResponse* other);
  friend void swap(CommonResponse& a, CommonResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommonResponse* New() const final {
    return CreateMaybeMessage<CommonResponse>(nullptr);
  }

  CommonResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommonResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CommonResponse& from);
  void MergeFrom(const CommonResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommonResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.CommonResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // optional string grpc_error_message = 4;
  bool has_grpc_error_message() const;
  void clear_grpc_error_message();
  static const int kGrpcErrorMessageFieldNumber = 4;
  const std::string& grpc_error_message() const;
  void set_grpc_error_message(const std::string& value);
  void set_grpc_error_message(std::string&& value);
  void set_grpc_error_message(const char* value);
  void set_grpc_error_message(const char* value, size_t size);
  std::string* mutable_grpc_error_message();
  std::string* release_grpc_error_message();
  void set_allocated_grpc_error_message(std::string* grpc_error_message);

  // optional string grpc_error_details = 5;
  bool has_grpc_error_details() const;
  void clear_grpc_error_details();
  static const int kGrpcErrorDetailsFieldNumber = 5;
  const std::string& grpc_error_details() const;
  void set_grpc_error_details(const std::string& value);
  void set_grpc_error_details(std::string&& value);
  void set_grpc_error_details(const char* value);
  void set_grpc_error_details(const char* value, size_t size);
  std::string* mutable_grpc_error_details();
  std::string* release_grpc_error_details();
  void set_allocated_grpc_error_details(std::string* grpc_error_details);

  // required .usersystem.ResponseCode code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::usersystem::ResponseCode code() const;
  void set_code(::usersystem::ResponseCode value);

  // optional int32 grpc_error_code = 3;
  bool has_grpc_error_code() const;
  void clear_grpc_error_code();
  static const int kGrpcErrorCodeFieldNumber = 3;
  ::PROTOBUF_NAMESPACE_ID::int32 grpc_error_code() const;
  void set_grpc_error_code(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:usersystem.CommonResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grpc_error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr grpc_error_details_;
  int code_;
  ::PROTOBUF_NAMESPACE_ID::int32 grpc_error_code_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.RegisterRequest) */ {
 public:
  RegisterRequest();
  virtual ~RegisterRequest();

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegisterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RegisterRequest* other);
  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterRequest* New() const final {
    return CreateMaybeMessage<RegisterRequest>(nullptr);
  }

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegisterRequest& from);
  void MergeFrom(const RegisterRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.RegisterRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // required string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // required string device_id = 3;
  bool has_device_id() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 3;
  const std::string& device_id() const;
  void set_device_id(const std::string& value);
  void set_device_id(std::string&& value);
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  std::string* mutable_device_id();
  std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);

  // required .usersystem.Platform platform = 4;
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 4;
  ::usersystem::Platform platform() const;
  void set_platform(::usersystem::Platform value);

  // @@protoc_insertion_point(class_scope:usersystem.RegisterRequest)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  int platform_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(nullptr);
  }

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.RegisterResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 3;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // required .usersystem.CommonResponse response = 1;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  const ::usersystem::CommonResponse& response() const;
  ::usersystem::CommonResponse* release_response();
  ::usersystem::CommonResponse* mutable_response();
  void set_allocated_response(::usersystem::CommonResponse* response);

  // optional .usersystem.UserModel userModel = 2;
  bool has_usermodel() const;
  void clear_usermodel();
  static const int kUserModelFieldNumber = 2;
  const ::usersystem::UserModel& usermodel() const;
  ::usersystem::UserModel* release_usermodel();
  ::usersystem::UserModel* mutable_usermodel();
  void set_allocated_usermodel(::usersystem::UserModel* usermodel);

  // @@protoc_insertion_point(class_scope:usersystem.RegisterResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::usersystem::CommonResponse* response_;
  ::usersystem::UserModel* usermodel_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const final {
    return CreateMaybeMessage<LoginRequest>(nullptr);
  }

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.LoginRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // required string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // required string device_id = 3;
  bool has_device_id() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 3;
  const std::string& device_id() const;
  void set_device_id(const std::string& value);
  void set_device_id(std::string&& value);
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  std::string* mutable_device_id();
  std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);

  // optional .usersystem.Geo geo = 5;
  bool has_geo() const;
  void clear_geo();
  static const int kGeoFieldNumber = 5;
  const ::usersystem::Geo& geo() const;
  ::usersystem::Geo* release_geo();
  ::usersystem::Geo* mutable_geo();
  void set_allocated_geo(::usersystem::Geo* geo);

  // required .usersystem.Platform platform = 4;
  bool has_platform() const;
  void clear_platform();
  static const int kPlatformFieldNumber = 4;
  ::usersystem::Platform platform() const;
  void set_platform(::usersystem::Platform value);

  // @@protoc_insertion_point(class_scope:usersystem.LoginRequest)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::usersystem::Geo* geo_;
  int platform_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const final {
    return CreateMaybeMessage<LoginResponse>(nullptr);
  }

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.LoginResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 3;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // required .usersystem.CommonResponse response = 1;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  const ::usersystem::CommonResponse& response() const;
  ::usersystem::CommonResponse* release_response();
  ::usersystem::CommonResponse* mutable_response();
  void set_allocated_response(::usersystem::CommonResponse* response);

  // optional .usersystem.UserModel userModel = 2;
  bool has_usermodel() const;
  void clear_usermodel();
  static const int kUserModelFieldNumber = 2;
  const ::usersystem::UserModel& usermodel() const;
  ::usersystem::UserModel* release_usermodel();
  ::usersystem::UserModel* mutable_usermodel();
  void set_allocated_usermodel(::usersystem::UserModel* usermodel);

  // @@protoc_insertion_point(class_scope:usersystem.LoginResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::usersystem::CommonResponse* response_;
  ::usersystem::UserModel* usermodel_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class CheckLoginRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.CheckLoginRequest) */ {
 public:
  CheckLoginRequest();
  virtual ~CheckLoginRequest();

  CheckLoginRequest(const CheckLoginRequest& from);
  CheckLoginRequest(CheckLoginRequest&& from) noexcept
    : CheckLoginRequest() {
    *this = ::std::move(from);
  }

  inline CheckLoginRequest& operator=(const CheckLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckLoginRequest& operator=(CheckLoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CheckLoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckLoginRequest* internal_default_instance() {
    return reinterpret_cast<const CheckLoginRequest*>(
               &_CheckLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CheckLoginRequest* other);
  friend void swap(CheckLoginRequest& a, CheckLoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckLoginRequest* New() const final {
    return CreateMaybeMessage<CheckLoginRequest>(nullptr);
  }

  CheckLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckLoginRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CheckLoginRequest& from);
  void MergeFrom(const CheckLoginRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckLoginRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.CheckLoginRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // required string token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // required string device_id = 3;
  bool has_device_id() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 3;
  const std::string& device_id() const;
  void set_device_id(const std::string& value);
  void set_device_id(std::string&& value);
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  std::string* mutable_device_id();
  std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);

  // optional .usersystem.Geo geo = 5;
  bool has_geo() const;
  void clear_geo();
  static const int kGeoFieldNumber = 5;
  const ::usersystem::Geo& geo() const;
  ::usersystem::Geo* release_geo();
  ::usersystem::Geo* mutable_geo();
  void set_allocated_geo(::usersystem::Geo* geo);

  // required .usersystem.Platform from_platform = 4;
  bool has_from_platform() const;
  void clear_from_platform();
  static const int kFromPlatformFieldNumber = 4;
  ::usersystem::Platform from_platform() const;
  void set_from_platform(::usersystem::Platform value);

  // @@protoc_insertion_point(class_scope:usersystem.CheckLoginRequest)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::usersystem::Geo* geo_;
  int from_platform_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class CheckLoginResponse :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.CheckLoginResponse) */ {
 public:
  CheckLoginResponse();
  virtual ~CheckLoginResponse();

  CheckLoginResponse(const CheckLoginResponse& from);
  CheckLoginResponse(CheckLoginResponse&& from) noexcept
    : CheckLoginResponse() {
    *this = ::std::move(from);
  }

  inline CheckLoginResponse& operator=(const CheckLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckLoginResponse& operator=(CheckLoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CheckLoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckLoginResponse* internal_default_instance() {
    return reinterpret_cast<const CheckLoginResponse*>(
               &_CheckLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CheckLoginResponse* other);
  friend void swap(CheckLoginResponse& a, CheckLoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CheckLoginResponse* New() const final {
    return CreateMaybeMessage<CheckLoginResponse>(nullptr);
  }

  CheckLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckLoginResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CheckLoginResponse& from);
  void MergeFrom(const CheckLoginResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckLoginResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.CheckLoginResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .usersystem.CommonResponse response = 1;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 1;
  const ::usersystem::CommonResponse& response() const;
  ::usersystem::CommonResponse* release_response();
  ::usersystem::CommonResponse* mutable_response();
  void set_allocated_response(::usersystem::CommonResponse* response);

  // @@protoc_insertion_point(class_scope:usersystem.CheckLoginResponse)
 private:
  class HasBitSetters;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::usersystem::CommonResponse* response_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// -------------------------------------------------------------------

class LogoutRequest :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:usersystem.LogoutRequest) */ {
 public:
  LogoutRequest();
  virtual ~LogoutRequest();

  LogoutRequest(const LogoutRequest& from);
  LogoutRequest(LogoutRequest&& from) noexcept
    : LogoutRequest() {
    *this = ::std::move(from);
  }

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRequest& operator=(LogoutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LogoutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogoutRequest* internal_default_instance() {
    return reinterpret_cast<const LogoutRequest*>(
               &_LogoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(LogoutRequest* other);
  friend void swap(LogoutRequest& a, LogoutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogoutRequest* New() const final {
    return CreateMaybeMessage<LogoutRequest>(nullptr);
  }

  LogoutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogoutRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LogoutRequest& from);
  void MergeFrom(const LogoutRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogoutRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "usersystem.LogoutRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);

  // required string token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);

  // @@protoc_insertion_point(class_scope:usersystem.LogoutRequest)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  friend struct ::TableStruct_usersystem_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Geo

// required double lat = 1;
inline bool Geo::has_lat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geo::clear_lat() {
  lat_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double Geo::lat() const {
  // @@protoc_insertion_point(field_get:usersystem.Geo.lat)
  return lat_;
}
inline void Geo::set_lat(double value) {
  _has_bits_[0] |= 0x00000001u;
  lat_ = value;
  // @@protoc_insertion_point(field_set:usersystem.Geo.lat)
}

// required double lng = 2;
inline bool Geo::has_lng() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geo::clear_lng() {
  lng_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double Geo::lng() const {
  // @@protoc_insertion_point(field_get:usersystem.Geo.lng)
  return lng_;
}
inline void Geo::set_lng(double value) {
  _has_bits_[0] |= 0x00000002u;
  lng_ = value;
  // @@protoc_insertion_point(field_set:usersystem.Geo.lng)
}

// -------------------------------------------------------------------

// UserModel

// required string id = 1;
inline bool UserModel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserModel::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserModel::id() const {
  // @@protoc_insertion_point(field_get:usersystem.UserModel.id)
  return id_.GetNoArena();
}
inline void UserModel::set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.UserModel.id)
}
inline void UserModel::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.UserModel.id)
}
inline void UserModel::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.UserModel.id)
}
inline void UserModel::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.UserModel.id)
}
inline std::string* UserModel::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.UserModel.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserModel::release_id() {
  // @@protoc_insertion_point(field_release:usersystem.UserModel.id)
  if (!has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserModel::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserModel.id)
}

// required string username = 2;
inline bool UserModel::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserModel::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserModel::username() const {
  // @@protoc_insertion_point(field_get:usersystem.UserModel.username)
  return username_.GetNoArena();
}
inline void UserModel::set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.UserModel.username)
}
inline void UserModel::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.UserModel.username)
}
inline void UserModel::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.UserModel.username)
}
inline void UserModel::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.UserModel.username)
}
inline std::string* UserModel::mutable_username() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:usersystem.UserModel.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserModel::release_username() {
  // @@protoc_insertion_point(field_release:usersystem.UserModel.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserModel::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserModel.username)
}

// optional string password = 3;
inline bool UserModel::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserModel::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserModel::password() const {
  // @@protoc_insertion_point(field_get:usersystem.UserModel.password)
  return password_.GetNoArena();
}
inline void UserModel::set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.UserModel.password)
}
inline void UserModel::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.UserModel.password)
}
inline void UserModel::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.UserModel.password)
}
inline void UserModel::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.UserModel.password)
}
inline std::string* UserModel::mutable_password() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:usersystem.UserModel.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserModel::release_password() {
  // @@protoc_insertion_point(field_release:usersystem.UserModel.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserModel::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserModel.password)
}

// optional int32 age = 4;
inline bool UserModel::has_age() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserModel::clear_age() {
  age_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserModel::age() const {
  // @@protoc_insertion_point(field_get:usersystem.UserModel.age)
  return age_;
}
inline void UserModel::set_age(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  age_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserModel.age)
}

// optional .usersystem.UserModel.UserGender gender = 5;
inline bool UserModel::has_gender() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserModel::clear_gender() {
  gender_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::usersystem::UserModel_UserGender UserModel::gender() const {
  // @@protoc_insertion_point(field_get:usersystem.UserModel.gender)
  return static_cast< ::usersystem::UserModel_UserGender >(gender_);
}
inline void UserModel::set_gender(::usersystem::UserModel_UserGender value) {
  assert(::usersystem::UserModel_UserGender_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  gender_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserModel.gender)
}

// optional string phone_number = 6;
inline bool UserModel::has_phone_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserModel::clear_phone_number() {
  phone_number_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserModel::phone_number() const {
  // @@protoc_insertion_point(field_get:usersystem.UserModel.phone_number)
  return phone_number_.GetNoArena();
}
inline void UserModel::set_phone_number(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  phone_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.UserModel.phone_number)
}
inline void UserModel::set_phone_number(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  phone_number_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.UserModel.phone_number)
}
inline void UserModel::set_phone_number(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  phone_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.UserModel.phone_number)
}
inline void UserModel::set_phone_number(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  phone_number_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.UserModel.phone_number)
}
inline std::string* UserModel::mutable_phone_number() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:usersystem.UserModel.phone_number)
  return phone_number_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserModel::release_phone_number() {
  // @@protoc_insertion_point(field_release:usersystem.UserModel.phone_number)
  if (!has_phone_number()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return phone_number_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserModel::set_allocated_phone_number(std::string* phone_number) {
  if (phone_number != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  phone_number_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), phone_number);
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserModel.phone_number)
}

// optional .usersystem.Geo geo = 7;
inline bool UserModel::has_geo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserModel::clear_geo() {
  if (geo_ != nullptr) geo_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::usersystem::Geo& UserModel::geo() const {
  const ::usersystem::Geo* p = geo_;
  // @@protoc_insertion_point(field_get:usersystem.UserModel.geo)
  return p != nullptr ? *p : *reinterpret_cast<const ::usersystem::Geo*>(
      &::usersystem::_Geo_default_instance_);
}
inline ::usersystem::Geo* UserModel::release_geo() {
  // @@protoc_insertion_point(field_release:usersystem.UserModel.geo)
  _has_bits_[0] &= ~0x00000010u;
  ::usersystem::Geo* temp = geo_;
  geo_ = nullptr;
  return temp;
}
inline ::usersystem::Geo* UserModel::mutable_geo() {
  _has_bits_[0] |= 0x00000010u;
  if (geo_ == nullptr) {
    auto* p = CreateMaybeMessage<::usersystem::Geo>(GetArenaNoVirtual());
    geo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:usersystem.UserModel.geo)
  return geo_;
}
inline void UserModel::set_allocated_geo(::usersystem::Geo* geo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete geo_;
  }
  if (geo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      geo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  geo_ = geo;
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserModel.geo)
}

// optional uint64 create_at_millis = 8;
inline bool UserModel::has_create_at_millis() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserModel::clear_create_at_millis() {
  create_at_millis_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserModel::create_at_millis() const {
  // @@protoc_insertion_point(field_get:usersystem.UserModel.create_at_millis)
  return create_at_millis_;
}
inline void UserModel::set_create_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  create_at_millis_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserModel.create_at_millis)
}

// optional uint64 update_at_millis = 9;
inline bool UserModel::has_update_at_millis() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserModel::clear_update_at_millis() {
  update_at_millis_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserModel::update_at_millis() const {
  // @@protoc_insertion_point(field_get:usersystem.UserModel.update_at_millis)
  return update_at_millis_;
}
inline void UserModel::set_update_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  update_at_millis_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserModel.update_at_millis)
}

// -------------------------------------------------------------------

// UserLoginHistoryModel

// required string id = 1;
inline bool UserLoginHistoryModel::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginHistoryModel::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserLoginHistoryModel::id() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.id)
  return id_.GetNoArena();
}
inline void UserLoginHistoryModel::set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.id)
}
inline void UserLoginHistoryModel::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.UserLoginHistoryModel.id)
}
inline void UserLoginHistoryModel::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.UserLoginHistoryModel.id)
}
inline void UserLoginHistoryModel::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.UserLoginHistoryModel.id)
}
inline std::string* UserLoginHistoryModel::mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.UserLoginHistoryModel.id)
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserLoginHistoryModel::release_id() {
  // @@protoc_insertion_point(field_release:usersystem.UserLoginHistoryModel.id)
  if (!has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserLoginHistoryModel::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserLoginHistoryModel.id)
}

// required string username = 2;
inline bool UserLoginHistoryModel::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginHistoryModel::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserLoginHistoryModel::username() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.username)
  return username_.GetNoArena();
}
inline void UserLoginHistoryModel::set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.username)
}
inline void UserLoginHistoryModel::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.UserLoginHistoryModel.username)
}
inline void UserLoginHistoryModel::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.UserLoginHistoryModel.username)
}
inline void UserLoginHistoryModel::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.UserLoginHistoryModel.username)
}
inline std::string* UserLoginHistoryModel::mutable_username() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:usersystem.UserLoginHistoryModel.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserLoginHistoryModel::release_username() {
  // @@protoc_insertion_point(field_release:usersystem.UserLoginHistoryModel.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserLoginHistoryModel::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserLoginHistoryModel.username)
}

// required string token = 3;
inline bool UserLoginHistoryModel::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLoginHistoryModel::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UserLoginHistoryModel::token() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.token)
  return token_.GetNoArena();
}
inline void UserLoginHistoryModel::set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.token)
}
inline void UserLoginHistoryModel::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.UserLoginHistoryModel.token)
}
inline void UserLoginHistoryModel::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.UserLoginHistoryModel.token)
}
inline void UserLoginHistoryModel::set_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.UserLoginHistoryModel.token)
}
inline std::string* UserLoginHistoryModel::mutable_token() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:usersystem.UserLoginHistoryModel.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserLoginHistoryModel::release_token() {
  // @@protoc_insertion_point(field_release:usersystem.UserLoginHistoryModel.token)
  if (!has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserLoginHistoryModel::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserLoginHistoryModel.token)
}

// required string device_id = 4;
inline bool UserLoginHistoryModel::has_device_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLoginHistoryModel::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& UserLoginHistoryModel::device_id() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.device_id)
  return device_id_.GetNoArena();
}
inline void UserLoginHistoryModel::set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.device_id)
}
inline void UserLoginHistoryModel::set_device_id(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  device_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.UserLoginHistoryModel.device_id)
}
inline void UserLoginHistoryModel::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.UserLoginHistoryModel.device_id)
}
inline void UserLoginHistoryModel::set_device_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.UserLoginHistoryModel.device_id)
}
inline std::string* UserLoginHistoryModel::mutable_device_id() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:usersystem.UserLoginHistoryModel.device_id)
  return device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserLoginHistoryModel::release_device_id() {
  // @@protoc_insertion_point(field_release:usersystem.UserLoginHistoryModel.device_id)
  if (!has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserLoginHistoryModel::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:usersystem.UserLoginHistoryModel.device_id)
}

// required .usersystem.Platform from_platform = 5;
inline bool UserLoginHistoryModel::has_from_platform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLoginHistoryModel::clear_from_platform() {
  from_platform_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::usersystem::Platform UserLoginHistoryModel::from_platform() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.from_platform)
  return static_cast< ::usersystem::Platform >(from_platform_);
}
inline void UserLoginHistoryModel::set_from_platform(::usersystem::Platform value) {
  assert(::usersystem::Platform_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  from_platform_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.from_platform)
}

// required bool is_valid = 6;
inline bool UserLoginHistoryModel::has_is_valid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserLoginHistoryModel::clear_is_valid() {
  is_valid_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool UserLoginHistoryModel::is_valid() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.is_valid)
  return is_valid_;
}
inline void UserLoginHistoryModel::set_is_valid(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_valid_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.is_valid)
}

// optional uint64 create_at_millis = 7;
inline bool UserLoginHistoryModel::has_create_at_millis() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserLoginHistoryModel::clear_create_at_millis() {
  create_at_millis_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserLoginHistoryModel::create_at_millis() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.create_at_millis)
  return create_at_millis_;
}
inline void UserLoginHistoryModel::set_create_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  create_at_millis_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.create_at_millis)
}

// optional uint64 update_at_millis = 8;
inline bool UserLoginHistoryModel::has_update_at_millis() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserLoginHistoryModel::clear_update_at_millis() {
  update_at_millis_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserLoginHistoryModel::update_at_millis() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.update_at_millis)
  return update_at_millis_;
}
inline void UserLoginHistoryModel::set_update_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  update_at_millis_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.update_at_millis)
}

// optional uint64 expire_at_millis = 9;
inline bool UserLoginHistoryModel::has_expire_at_millis() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserLoginHistoryModel::clear_expire_at_millis() {
  expire_at_millis_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UserLoginHistoryModel::expire_at_millis() const {
  // @@protoc_insertion_point(field_get:usersystem.UserLoginHistoryModel.expire_at_millis)
  return expire_at_millis_;
}
inline void UserLoginHistoryModel::set_expire_at_millis(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  expire_at_millis_ = value;
  // @@protoc_insertion_point(field_set:usersystem.UserLoginHistoryModel.expire_at_millis)
}

// -------------------------------------------------------------------

// CommonResponse

// required .usersystem.ResponseCode code = 1;
inline bool CommonResponse::has_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonResponse::clear_code() {
  code_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::usersystem::ResponseCode CommonResponse::code() const {
  // @@protoc_insertion_point(field_get:usersystem.CommonResponse.code)
  return static_cast< ::usersystem::ResponseCode >(code_);
}
inline void CommonResponse::set_code(::usersystem::ResponseCode value) {
  assert(::usersystem::ResponseCode_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  code_ = value;
  // @@protoc_insertion_point(field_set:usersystem.CommonResponse.code)
}

// optional string message = 2;
inline bool CommonResponse::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonResponse::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommonResponse::message() const {
  // @@protoc_insertion_point(field_get:usersystem.CommonResponse.message)
  return message_.GetNoArena();
}
inline void CommonResponse::set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.CommonResponse.message)
}
inline void CommonResponse::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.CommonResponse.message)
}
inline void CommonResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.CommonResponse.message)
}
inline void CommonResponse::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.CommonResponse.message)
}
inline std::string* CommonResponse::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.CommonResponse.message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CommonResponse::release_message() {
  // @@protoc_insertion_point(field_release:usersystem.CommonResponse.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CommonResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:usersystem.CommonResponse.message)
}

// optional int32 grpc_error_code = 3;
inline bool CommonResponse::has_grpc_error_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonResponse::clear_grpc_error_code() {
  grpc_error_code_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommonResponse::grpc_error_code() const {
  // @@protoc_insertion_point(field_get:usersystem.CommonResponse.grpc_error_code)
  return grpc_error_code_;
}
inline void CommonResponse::set_grpc_error_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  grpc_error_code_ = value;
  // @@protoc_insertion_point(field_set:usersystem.CommonResponse.grpc_error_code)
}

// optional string grpc_error_message = 4;
inline bool CommonResponse::has_grpc_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonResponse::clear_grpc_error_message() {
  grpc_error_message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommonResponse::grpc_error_message() const {
  // @@protoc_insertion_point(field_get:usersystem.CommonResponse.grpc_error_message)
  return grpc_error_message_.GetNoArena();
}
inline void CommonResponse::set_grpc_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  grpc_error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.CommonResponse.grpc_error_message)
}
inline void CommonResponse::set_grpc_error_message(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  grpc_error_message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.CommonResponse.grpc_error_message)
}
inline void CommonResponse::set_grpc_error_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  grpc_error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.CommonResponse.grpc_error_message)
}
inline void CommonResponse::set_grpc_error_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  grpc_error_message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.CommonResponse.grpc_error_message)
}
inline std::string* CommonResponse::mutable_grpc_error_message() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:usersystem.CommonResponse.grpc_error_message)
  return grpc_error_message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CommonResponse::release_grpc_error_message() {
  // @@protoc_insertion_point(field_release:usersystem.CommonResponse.grpc_error_message)
  if (!has_grpc_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return grpc_error_message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CommonResponse::set_allocated_grpc_error_message(std::string* grpc_error_message) {
  if (grpc_error_message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  grpc_error_message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), grpc_error_message);
  // @@protoc_insertion_point(field_set_allocated:usersystem.CommonResponse.grpc_error_message)
}

// optional string grpc_error_details = 5;
inline bool CommonResponse::has_grpc_error_details() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonResponse::clear_grpc_error_details() {
  grpc_error_details_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CommonResponse::grpc_error_details() const {
  // @@protoc_insertion_point(field_get:usersystem.CommonResponse.grpc_error_details)
  return grpc_error_details_.GetNoArena();
}
inline void CommonResponse::set_grpc_error_details(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  grpc_error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.CommonResponse.grpc_error_details)
}
inline void CommonResponse::set_grpc_error_details(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  grpc_error_details_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.CommonResponse.grpc_error_details)
}
inline void CommonResponse::set_grpc_error_details(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  grpc_error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.CommonResponse.grpc_error_details)
}
inline void CommonResponse::set_grpc_error_details(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  grpc_error_details_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.CommonResponse.grpc_error_details)
}
inline std::string* CommonResponse::mutable_grpc_error_details() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:usersystem.CommonResponse.grpc_error_details)
  return grpc_error_details_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CommonResponse::release_grpc_error_details() {
  // @@protoc_insertion_point(field_release:usersystem.CommonResponse.grpc_error_details)
  if (!has_grpc_error_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return grpc_error_details_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CommonResponse::set_allocated_grpc_error_details(std::string* grpc_error_details) {
  if (grpc_error_details != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  grpc_error_details_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), grpc_error_details);
  // @@protoc_insertion_point(field_set_allocated:usersystem.CommonResponse.grpc_error_details)
}

// -------------------------------------------------------------------

// RegisterRequest

// required string username = 1;
inline bool RegisterRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterRequest::username() const {
  // @@protoc_insertion_point(field_get:usersystem.RegisterRequest.username)
  return username_.GetNoArena();
}
inline void RegisterRequest::set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.RegisterRequest.username)
}
inline void RegisterRequest::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.RegisterRequest.username)
}
inline void RegisterRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.RegisterRequest.username)
}
inline void RegisterRequest::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.RegisterRequest.username)
}
inline std::string* RegisterRequest::mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.RegisterRequest.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegisterRequest::release_username() {
  // @@protoc_insertion_point(field_release:usersystem.RegisterRequest.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:usersystem.RegisterRequest.username)
}

// required string password = 2;
inline bool RegisterRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegisterRequest::password() const {
  // @@protoc_insertion_point(field_get:usersystem.RegisterRequest.password)
  return password_.GetNoArena();
}
inline void RegisterRequest::set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.RegisterRequest.password)
}
inline void RegisterRequest::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.RegisterRequest.password)
}
inline void RegisterRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.RegisterRequest.password)
}
inline void RegisterRequest::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.RegisterRequest.password)
}
inline std::string* RegisterRequest::mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:usersystem.RegisterRequest.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegisterRequest::release_password() {
  // @@protoc_insertion_point(field_release:usersystem.RegisterRequest.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:usersystem.RegisterRequest.password)
}

// required string device_id = 3;
inline bool RegisterRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterRequest::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegisterRequest::device_id() const {
  // @@protoc_insertion_point(field_get:usersystem.RegisterRequest.device_id)
  return device_id_.GetNoArena();
}
inline void RegisterRequest::set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.RegisterRequest.device_id)
}
inline void RegisterRequest::set_device_id(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.RegisterRequest.device_id)
}
inline void RegisterRequest::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.RegisterRequest.device_id)
}
inline void RegisterRequest::set_device_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.RegisterRequest.device_id)
}
inline std::string* RegisterRequest::mutable_device_id() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:usersystem.RegisterRequest.device_id)
  return device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegisterRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:usersystem.RegisterRequest.device_id)
  if (!has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:usersystem.RegisterRequest.device_id)
}

// required .usersystem.Platform platform = 4;
inline bool RegisterRequest::has_platform() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegisterRequest::clear_platform() {
  platform_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::usersystem::Platform RegisterRequest::platform() const {
  // @@protoc_insertion_point(field_get:usersystem.RegisterRequest.platform)
  return static_cast< ::usersystem::Platform >(platform_);
}
inline void RegisterRequest::set_platform(::usersystem::Platform value) {
  assert(::usersystem::Platform_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  platform_ = value;
  // @@protoc_insertion_point(field_set:usersystem.RegisterRequest.platform)
}

// -------------------------------------------------------------------

// RegisterResponse

// required .usersystem.CommonResponse response = 1;
inline bool RegisterResponse::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterResponse::clear_response() {
  if (response_ != nullptr) response_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::usersystem::CommonResponse& RegisterResponse::response() const {
  const ::usersystem::CommonResponse* p = response_;
  // @@protoc_insertion_point(field_get:usersystem.RegisterResponse.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::usersystem::CommonResponse*>(
      &::usersystem::_CommonResponse_default_instance_);
}
inline ::usersystem::CommonResponse* RegisterResponse::release_response() {
  // @@protoc_insertion_point(field_release:usersystem.RegisterResponse.response)
  _has_bits_[0] &= ~0x00000002u;
  ::usersystem::CommonResponse* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::usersystem::CommonResponse* RegisterResponse::mutable_response() {
  _has_bits_[0] |= 0x00000002u;
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::usersystem::CommonResponse>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:usersystem.RegisterResponse.response)
  return response_;
}
inline void RegisterResponse::set_allocated_response(::usersystem::CommonResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:usersystem.RegisterResponse.response)
}

// optional .usersystem.UserModel userModel = 2;
inline bool RegisterResponse::has_usermodel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterResponse::clear_usermodel() {
  if (usermodel_ != nullptr) usermodel_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::usersystem::UserModel& RegisterResponse::usermodel() const {
  const ::usersystem::UserModel* p = usermodel_;
  // @@protoc_insertion_point(field_get:usersystem.RegisterResponse.userModel)
  return p != nullptr ? *p : *reinterpret_cast<const ::usersystem::UserModel*>(
      &::usersystem::_UserModel_default_instance_);
}
inline ::usersystem::UserModel* RegisterResponse::release_usermodel() {
  // @@protoc_insertion_point(field_release:usersystem.RegisterResponse.userModel)
  _has_bits_[0] &= ~0x00000004u;
  ::usersystem::UserModel* temp = usermodel_;
  usermodel_ = nullptr;
  return temp;
}
inline ::usersystem::UserModel* RegisterResponse::mutable_usermodel() {
  _has_bits_[0] |= 0x00000004u;
  if (usermodel_ == nullptr) {
    auto* p = CreateMaybeMessage<::usersystem::UserModel>(GetArenaNoVirtual());
    usermodel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:usersystem.RegisterResponse.userModel)
  return usermodel_;
}
inline void RegisterResponse::set_allocated_usermodel(::usersystem::UserModel* usermodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete usermodel_;
  }
  if (usermodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      usermodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usermodel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  usermodel_ = usermodel;
  // @@protoc_insertion_point(field_set_allocated:usersystem.RegisterResponse.userModel)
}

// optional string token = 3;
inline bool RegisterResponse::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegisterResponse::token() const {
  // @@protoc_insertion_point(field_get:usersystem.RegisterResponse.token)
  return token_.GetNoArena();
}
inline void RegisterResponse::set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.RegisterResponse.token)
}
inline void RegisterResponse::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.RegisterResponse.token)
}
inline void RegisterResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.RegisterResponse.token)
}
inline void RegisterResponse::set_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.RegisterResponse.token)
}
inline std::string* RegisterResponse::mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.RegisterResponse.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegisterResponse::release_token() {
  // @@protoc_insertion_point(field_release:usersystem.RegisterResponse.token)
  if (!has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:usersystem.RegisterResponse.token)
}

// -------------------------------------------------------------------

// LoginRequest

// required string username = 1;
inline bool LoginRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginRequest::username() const {
  // @@protoc_insertion_point(field_get:usersystem.LoginRequest.username)
  return username_.GetNoArena();
}
inline void LoginRequest::set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.LoginRequest.username)
}
inline void LoginRequest::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.LoginRequest.username)
}
inline void LoginRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.LoginRequest.username)
}
inline void LoginRequest::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.LoginRequest.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:usersystem.LoginRequest.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:usersystem.LoginRequest.username)
}

// required string password = 2;
inline bool LoginRequest::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:usersystem.LoginRequest.password)
  return password_.GetNoArena();
}
inline void LoginRequest::set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.LoginRequest.password)
}
inline void LoginRequest::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:usersystem.LoginRequest.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:usersystem.LoginRequest.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:usersystem.LoginRequest.password)
}

// required string device_id = 3;
inline bool LoginRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LoginRequest::device_id() const {
  // @@protoc_insertion_point(field_get:usersystem.LoginRequest.device_id)
  return device_id_.GetNoArena();
}
inline void LoginRequest::set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.LoginRequest.device_id)
}
inline std::string* LoginRequest::mutable_device_id() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:usersystem.LoginRequest.device_id)
  return device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:usersystem.LoginRequest.device_id)
  if (!has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:usersystem.LoginRequest.device_id)
}

// required .usersystem.Platform platform = 4;
inline bool LoginRequest::has_platform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::clear_platform() {
  platform_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::usersystem::Platform LoginRequest::platform() const {
  // @@protoc_insertion_point(field_get:usersystem.LoginRequest.platform)
  return static_cast< ::usersystem::Platform >(platform_);
}
inline void LoginRequest::set_platform(::usersystem::Platform value) {
  assert(::usersystem::Platform_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  platform_ = value;
  // @@protoc_insertion_point(field_set:usersystem.LoginRequest.platform)
}

// optional .usersystem.Geo geo = 5;
inline bool LoginRequest::has_geo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::clear_geo() {
  if (geo_ != nullptr) geo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::usersystem::Geo& LoginRequest::geo() const {
  const ::usersystem::Geo* p = geo_;
  // @@protoc_insertion_point(field_get:usersystem.LoginRequest.geo)
  return p != nullptr ? *p : *reinterpret_cast<const ::usersystem::Geo*>(
      &::usersystem::_Geo_default_instance_);
}
inline ::usersystem::Geo* LoginRequest::release_geo() {
  // @@protoc_insertion_point(field_release:usersystem.LoginRequest.geo)
  _has_bits_[0] &= ~0x00000008u;
  ::usersystem::Geo* temp = geo_;
  geo_ = nullptr;
  return temp;
}
inline ::usersystem::Geo* LoginRequest::mutable_geo() {
  _has_bits_[0] |= 0x00000008u;
  if (geo_ == nullptr) {
    auto* p = CreateMaybeMessage<::usersystem::Geo>(GetArenaNoVirtual());
    geo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:usersystem.LoginRequest.geo)
  return geo_;
}
inline void LoginRequest::set_allocated_geo(::usersystem::Geo* geo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete geo_;
  }
  if (geo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      geo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  geo_ = geo;
  // @@protoc_insertion_point(field_set_allocated:usersystem.LoginRequest.geo)
}

// -------------------------------------------------------------------

// LoginResponse

// required .usersystem.CommonResponse response = 1;
inline bool LoginResponse::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::clear_response() {
  if (response_ != nullptr) response_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::usersystem::CommonResponse& LoginResponse::response() const {
  const ::usersystem::CommonResponse* p = response_;
  // @@protoc_insertion_point(field_get:usersystem.LoginResponse.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::usersystem::CommonResponse*>(
      &::usersystem::_CommonResponse_default_instance_);
}
inline ::usersystem::CommonResponse* LoginResponse::release_response() {
  // @@protoc_insertion_point(field_release:usersystem.LoginResponse.response)
  _has_bits_[0] &= ~0x00000002u;
  ::usersystem::CommonResponse* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::usersystem::CommonResponse* LoginResponse::mutable_response() {
  _has_bits_[0] |= 0x00000002u;
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::usersystem::CommonResponse>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:usersystem.LoginResponse.response)
  return response_;
}
inline void LoginResponse::set_allocated_response(::usersystem::CommonResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:usersystem.LoginResponse.response)
}

// optional .usersystem.UserModel userModel = 2;
inline bool LoginResponse::has_usermodel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::clear_usermodel() {
  if (usermodel_ != nullptr) usermodel_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::usersystem::UserModel& LoginResponse::usermodel() const {
  const ::usersystem::UserModel* p = usermodel_;
  // @@protoc_insertion_point(field_get:usersystem.LoginResponse.userModel)
  return p != nullptr ? *p : *reinterpret_cast<const ::usersystem::UserModel*>(
      &::usersystem::_UserModel_default_instance_);
}
inline ::usersystem::UserModel* LoginResponse::release_usermodel() {
  // @@protoc_insertion_point(field_release:usersystem.LoginResponse.userModel)
  _has_bits_[0] &= ~0x00000004u;
  ::usersystem::UserModel* temp = usermodel_;
  usermodel_ = nullptr;
  return temp;
}
inline ::usersystem::UserModel* LoginResponse::mutable_usermodel() {
  _has_bits_[0] |= 0x00000004u;
  if (usermodel_ == nullptr) {
    auto* p = CreateMaybeMessage<::usersystem::UserModel>(GetArenaNoVirtual());
    usermodel_ = p;
  }
  // @@protoc_insertion_point(field_mutable:usersystem.LoginResponse.userModel)
  return usermodel_;
}
inline void LoginResponse::set_allocated_usermodel(::usersystem::UserModel* usermodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete usermodel_;
  }
  if (usermodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      usermodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, usermodel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  usermodel_ = usermodel;
  // @@protoc_insertion_point(field_set_allocated:usersystem.LoginResponse.userModel)
}

// optional string token = 3;
inline bool LoginResponse::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:usersystem.LoginResponse.token)
  return token_.GetNoArena();
}
inline void LoginResponse::set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.LoginResponse.token)
}
inline void LoginResponse::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.LoginResponse.token)
}
inline void LoginResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.LoginResponse.token)
}
inline void LoginResponse::set_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.LoginResponse.token)
}
inline std::string* LoginResponse::mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.LoginResponse.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginResponse::release_token() {
  // @@protoc_insertion_point(field_release:usersystem.LoginResponse.token)
  if (!has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:usersystem.LoginResponse.token)
}

// -------------------------------------------------------------------

// CheckLoginRequest

// required string username = 1;
inline bool CheckLoginRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckLoginRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckLoginRequest::username() const {
  // @@protoc_insertion_point(field_get:usersystem.CheckLoginRequest.username)
  return username_.GetNoArena();
}
inline void CheckLoginRequest::set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.CheckLoginRequest.username)
}
inline void CheckLoginRequest::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.CheckLoginRequest.username)
}
inline void CheckLoginRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.CheckLoginRequest.username)
}
inline void CheckLoginRequest::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.CheckLoginRequest.username)
}
inline std::string* CheckLoginRequest::mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.CheckLoginRequest.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckLoginRequest::release_username() {
  // @@protoc_insertion_point(field_release:usersystem.CheckLoginRequest.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckLoginRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:usersystem.CheckLoginRequest.username)
}

// required string token = 2;
inline bool CheckLoginRequest::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckLoginRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CheckLoginRequest::token() const {
  // @@protoc_insertion_point(field_get:usersystem.CheckLoginRequest.token)
  return token_.GetNoArena();
}
inline void CheckLoginRequest::set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.CheckLoginRequest.token)
}
inline void CheckLoginRequest::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.CheckLoginRequest.token)
}
inline void CheckLoginRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.CheckLoginRequest.token)
}
inline void CheckLoginRequest::set_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.CheckLoginRequest.token)
}
inline std::string* CheckLoginRequest::mutable_token() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:usersystem.CheckLoginRequest.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckLoginRequest::release_token() {
  // @@protoc_insertion_point(field_release:usersystem.CheckLoginRequest.token)
  if (!has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckLoginRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:usersystem.CheckLoginRequest.token)
}

// required string device_id = 3;
inline bool CheckLoginRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckLoginRequest::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CheckLoginRequest::device_id() const {
  // @@protoc_insertion_point(field_get:usersystem.CheckLoginRequest.device_id)
  return device_id_.GetNoArena();
}
inline void CheckLoginRequest::set_device_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.CheckLoginRequest.device_id)
}
inline void CheckLoginRequest::set_device_id(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.CheckLoginRequest.device_id)
}
inline void CheckLoginRequest::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.CheckLoginRequest.device_id)
}
inline void CheckLoginRequest::set_device_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  device_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.CheckLoginRequest.device_id)
}
inline std::string* CheckLoginRequest::mutable_device_id() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:usersystem.CheckLoginRequest.device_id)
  return device_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckLoginRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:usersystem.CheckLoginRequest.device_id)
  if (!has_device_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return device_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckLoginRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:usersystem.CheckLoginRequest.device_id)
}

// required .usersystem.Platform from_platform = 4;
inline bool CheckLoginRequest::has_from_platform() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckLoginRequest::clear_from_platform() {
  from_platform_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::usersystem::Platform CheckLoginRequest::from_platform() const {
  // @@protoc_insertion_point(field_get:usersystem.CheckLoginRequest.from_platform)
  return static_cast< ::usersystem::Platform >(from_platform_);
}
inline void CheckLoginRequest::set_from_platform(::usersystem::Platform value) {
  assert(::usersystem::Platform_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  from_platform_ = value;
  // @@protoc_insertion_point(field_set:usersystem.CheckLoginRequest.from_platform)
}

// optional .usersystem.Geo geo = 5;
inline bool CheckLoginRequest::has_geo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckLoginRequest::clear_geo() {
  if (geo_ != nullptr) geo_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::usersystem::Geo& CheckLoginRequest::geo() const {
  const ::usersystem::Geo* p = geo_;
  // @@protoc_insertion_point(field_get:usersystem.CheckLoginRequest.geo)
  return p != nullptr ? *p : *reinterpret_cast<const ::usersystem::Geo*>(
      &::usersystem::_Geo_default_instance_);
}
inline ::usersystem::Geo* CheckLoginRequest::release_geo() {
  // @@protoc_insertion_point(field_release:usersystem.CheckLoginRequest.geo)
  _has_bits_[0] &= ~0x00000008u;
  ::usersystem::Geo* temp = geo_;
  geo_ = nullptr;
  return temp;
}
inline ::usersystem::Geo* CheckLoginRequest::mutable_geo() {
  _has_bits_[0] |= 0x00000008u;
  if (geo_ == nullptr) {
    auto* p = CreateMaybeMessage<::usersystem::Geo>(GetArenaNoVirtual());
    geo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:usersystem.CheckLoginRequest.geo)
  return geo_;
}
inline void CheckLoginRequest::set_allocated_geo(::usersystem::Geo* geo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete geo_;
  }
  if (geo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      geo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  geo_ = geo;
  // @@protoc_insertion_point(field_set_allocated:usersystem.CheckLoginRequest.geo)
}

// -------------------------------------------------------------------

// CheckLoginResponse

// required .usersystem.CommonResponse response = 1;
inline bool CheckLoginResponse::has_response() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckLoginResponse::clear_response() {
  if (response_ != nullptr) response_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::usersystem::CommonResponse& CheckLoginResponse::response() const {
  const ::usersystem::CommonResponse* p = response_;
  // @@protoc_insertion_point(field_get:usersystem.CheckLoginResponse.response)
  return p != nullptr ? *p : *reinterpret_cast<const ::usersystem::CommonResponse*>(
      &::usersystem::_CommonResponse_default_instance_);
}
inline ::usersystem::CommonResponse* CheckLoginResponse::release_response() {
  // @@protoc_insertion_point(field_release:usersystem.CheckLoginResponse.response)
  _has_bits_[0] &= ~0x00000001u;
  ::usersystem::CommonResponse* temp = response_;
  response_ = nullptr;
  return temp;
}
inline ::usersystem::CommonResponse* CheckLoginResponse::mutable_response() {
  _has_bits_[0] |= 0x00000001u;
  if (response_ == nullptr) {
    auto* p = CreateMaybeMessage<::usersystem::CommonResponse>(GetArenaNoVirtual());
    response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:usersystem.CheckLoginResponse.response)
  return response_;
}
inline void CheckLoginResponse::set_allocated_response(::usersystem::CommonResponse* response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete response_;
  }
  if (response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, response, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  response_ = response;
  // @@protoc_insertion_point(field_set_allocated:usersystem.CheckLoginResponse.response)
}

// -------------------------------------------------------------------

// LogoutRequest

// required string username = 1;
inline bool LogoutRequest::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutRequest::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogoutRequest::username() const {
  // @@protoc_insertion_point(field_get:usersystem.LogoutRequest.username)
  return username_.GetNoArena();
}
inline void LogoutRequest::set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.LogoutRequest.username)
}
inline void LogoutRequest::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.LogoutRequest.username)
}
inline void LogoutRequest::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.LogoutRequest.username)
}
inline void LogoutRequest::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.LogoutRequest.username)
}
inline std::string* LogoutRequest::mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:usersystem.LogoutRequest.username)
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogoutRequest::release_username() {
  // @@protoc_insertion_point(field_release:usersystem.LogoutRequest.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogoutRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:usersystem.LogoutRequest.username)
}

// required string token = 2;
inline bool LogoutRequest::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogoutRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LogoutRequest::token() const {
  // @@protoc_insertion_point(field_get:usersystem.LogoutRequest.token)
  return token_.GetNoArena();
}
inline void LogoutRequest::set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:usersystem.LogoutRequest.token)
}
inline void LogoutRequest::set_token(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:usersystem.LogoutRequest.token)
}
inline void LogoutRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:usersystem.LogoutRequest.token)
}
inline void LogoutRequest::set_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:usersystem.LogoutRequest.token)
}
inline std::string* LogoutRequest::mutable_token() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:usersystem.LogoutRequest.token)
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LogoutRequest::release_token() {
  // @@protoc_insertion_point(field_release:usersystem.LogoutRequest.token)
  if (!has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LogoutRequest::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:usersystem.LogoutRequest.token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace usersystem

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::usersystem::UserModel_UserGender> : ::std::true_type {};
template <> struct is_proto_enum< ::usersystem::ResponseCode> : ::std::true_type {};
template <> struct is_proto_enum< ::usersystem::Platform> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_usersystem_2eproto
